---
title: "finalproject"
output: html_document
date: "2024-12-03"
---

```{r}
data <- read.csv("kaggle_survey_2020_responses.csv", stringsAsFactors = FALSE)
data <-data[-1,]
data
```

```{r}
# get relevent data first
relevant_columns <- data.frame(
  Age = data$Q1,
  Gender = data$Q2,
  Country = data$Q3,
  Education = data$Q4, # Adjust based on your actual column name
  Compensation = data$Q24 # Adjust based on your actual column name
)
relevant_columns
```

```{r}
selected_data <- relevant_columns %>%
  filter(!is.na(Age) & !is.na(Gender) & !is.na(Country) &
           !is.na(Education) & !is.na(Compensation))
selected_data

```
```{r}
ggplot(selected_data, aes(x = Education, y = Compensation)) +
  geom_boxplot(aes(fill = Education)) +
  labs(title = "Compensation by Education Level",
       x = "Education Level",
       y = "Compensation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
Q2
```{r}
selected_data <- data %>%
  select(Q6, Q7_Part_1:Q7_Part_12) %>%
  rename(
    Experience = Q6,
    Python = Q7_Part_1,
    R = Q7_Part_2,
    SQL = Q7_Part_3,
    C = Q7_Part_4,
    Cpp = Q7_Part_5,
    Java = Q7_Part_6,
    JavaScript = Q7_Part_7,
    Julia = Q7_Part_8,
    Swift = Q7_Part_9,
    Bash = Q7_Part_10,
    MATLAB = Q7_Part_11,
    None = Q7_Part_12
  )

selected_data <- selected_data %>%
  filter(Experience != "I have never written code")
```



```{r}


# Pivot table
pivot_data <- selected_data %>%
  pivot_longer(
    cols = Python:None, # Columns for programming languages
    names_to = "Language", # Create a new column for language names
    values_to = "Value"    # Create a new column for values (e.g., Yes/No or other indicators)
  ) %>%
  mutate(Value = ifelse(Value!='', 1, 0)) %>% # Convert "Yes" to 1 and others to 0
  group_by(Experience, Language) %>%
  summarize(Count = sum(Value, na.rm = TRUE), .groups = 'drop') %>%
  pivot_wider(
    names_from = Language, # Spread languages into columns
    values_from = Count,   # Fill with counts
    values_fill = 0        # Fill missing values with 0
  )

# Print the final pivot table
pivot_data <- pivot_data[-1,]
pivot_data

```

```{r}
create_pie_chart_with_legend <- function(column_name) {
  values <- pivot_data[[column_name]]
  labels <- pivot_data$Experience
  total <- sum(values)
  
  # Calculate percentages
  percentages <- round(values / total * 100, 1)
  legend_labels <- paste(labels, "(", percentages, "%)", sep = "")
  
  # Generate pie chart
  pie(values, 
      labels = NA, # Remove labels from the pie chart
      main = paste("Pie Chart for", column_name),
      col = rainbow(length(values)))
  
  # Add a legend
  legend("topright", legend = legend_labels, fill = rainbow(length(values)), cex = 0.8)
}

# Generate pie charts for each column
for (column in colnames(pivot_data)[-1]) {
  create_pie_chart_with_legend(column)
}

```




```{r}
pivot_data_long <- pivot_data %>%
  pivot_longer(cols = -Experience, names_to = "Language", values_to = "Usage")
pivot_data_long <- pivot_data_long %>%
  group_by(Language) %>%
  mutate(Proportion = Usage / sum(Usage))
pivot_data_long <- pivot_data_long %>%
  group_by(Language) %>%
  mutate(Proportion = Usage / sum(Usage))

# Create proportional stacked bar chart
ggplot(pivot_data_long, aes(x = Language, y = Proportion, fill = Experience)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(title = "Proportional Programming Language Usage by Experience Level", 
       x = "Programming Language", 
       y = "Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}
selected_data <- data %>%
  select(Q5, Q7_Part_1:Q7_Part_12) %>%
  rename(
    Industry = Q5,
    Python = Q7_Part_1,
    R = Q7_Part_2,
    SQL = Q7_Part_3,
    C = Q7_Part_4,
    Cpp = Q7_Part_5,
    Java = Q7_Part_6,
    JavaScript = Q7_Part_7,
    Julia = Q7_Part_8,
    Swift = Q7_Part_9,
    Bash = Q7_Part_10,
    MATLAB = Q7_Part_11,
    None = Q7_Part_12
  )
selected_data
```

```{r}
pivot_data <- selected_data %>%
  pivot_longer(
    cols = Python:None, # Columns for programming languages
    names_to = "Language", # Create a new column for language names
    values_to = "Value"    # Create a new column for values (e.g., Yes/No or other indicators)
  ) %>%
  mutate(Value = ifelse(Value!='', 1, 0)) %>% # Convert "Yes" to 1 and others to 0
  group_by(Industry, Language) %>%
  summarize(Count = sum(Value, na.rm = TRUE), .groups = 'drop') %>%
  pivot_wider(
    names_from = Language, # Spread languages into columns
    values_from = Count,   # Fill with counts
    values_fill = 0        # Fill missing values with 0
  )

# Print the final pivot table
pivot_data <- pivot_data[-1,]
pivot_data
```



```{r}
pivot_data_long <- pivot_data %>%
  pivot_longer(cols = -Industry, names_to = "Language", values_to = "Usage")
pivot_data_long <- pivot_data_long %>%
  group_by(Language) %>%
  mutate(Proportion = Usage / sum(Usage))
pivot_data_long <- pivot_data_long %>%
  group_by(Language) %>%
  mutate(Proportion = Usage / sum(Usage))

# Create proportional stacked bar chart
ggplot(pivot_data_long, aes(x = Language, y = Proportion, fill = Industry)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(title = "Proportional Programming Language Usage by Experience Level", 
       x = "Programming Language", 
       y = "Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}


# Define a larger, more varied color palette
color_palette <- brewer.pal(n = min(length(unique(pivot_data_long$Industry)), 12), "Set3")

# If more than 12 industries, expand the palette
if (length(unique(pivot_data_long$Industry)) > 12) {
  color_palette <- colorRampPalette(brewer.pal(12, "Set3"))(length(unique(pivot_data_long$Industry)))
}

# Plot with custom colors
ggplot(pivot_data_long, aes(x = Language, y = Proportion, fill = Industry)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = color_palette) +  # Apply the custom palette
  labs(title = "Proportional Programming Language Usage by Industry", 
       x = "Programming Language", 
       y = "Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Methods
Respondents' programming language usage and industry roles were derived from the survey's structured questions. Experience levels were classified into beginner, intermediate, and expert categories using the years of coding experience provided by the respondents. Proportional usage of programming languages across experience levels and industries was computed to identify trends. Visualizations were generated using stacked bar charts to compare the proportional adoption of programming languages across both experience levels and industry categories.
### Analysis
The analysis revealed distinct trends in programming language preferences among practitioners of different experience levels. Beginners showed a strong reliance on foundational languages like Python and SQL, while experts exhibited broader adoption of languages like R, Java, and Bash for advanced tasks. Across industries, Python emerged as a dominant language for data-related fields like data science and machine learning, whereas SQL had widespread adoption in roles such as data engineering and database management. More niche languages, such as Julia and MATLAB, saw usage concentrated in specialized roles like research scientists.

### Conclusion
The study revealed distinct programming language preferences that evolve with practitioners' experience levels and vary by industry roles. Python's widespread adoption across all levels underscores its utility as a foundational language in the data science ecosystem. Meanwhile, experts and industry specialists integrate niche languages to address specific challenges. These findings provide actionable insights for curriculum design in education, workforce training, and recruitment strategies, emphasizing the importance of Python for beginners and advanced language fluency for experienced professionals in specialized roles.